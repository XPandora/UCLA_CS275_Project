#pragma kernel CSMain
static const int threadGroupSize = 1024;

struct FishDataBuffer {
    int type; // 0: prey, 1: predator, 2: pacifist
    float3 position;
    float3 direction;

    float3 flockHeading;
    float3 flockCentre;
    float3 separationHeading;
    int numFlockmates;

    float totFear;
    float maxFear;
    float threat; // 0 for prey 1 for predator

     // eat
    float3 nearestPredatorPos;
    int eatenPreyNumber;
    // mate
    float3 desiredMatePos;
    int desiredMateIntention;
    float3 desiredMatesMatePos; // compare with self pos

};

RWStructuredBuffer<FishDataBuffer> fishDatBuffer;
int numFishes;
float viewRadius;
float avoidRadius;
float D0 = 100;

[numthreads(threadGroupSize,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float tmpMaxThreat = 0;
    float tempNearestDistSqr = 1000000000.0;
    for (int idxNeighbor = 0; idxNeighbor < numFishes; idxNeighbor ++) {
        if (id.x != idxNeighbor) {
            FishDataBuffer neighbor = fishDatBuffer[idxNeighbor];
            int neighbor_type = neighbor.type;
            
            float3 offset = neighbor.position - fishDatBuffer[id.x].position;
            float sqrDst = offset.x * offset.x + offset.y * offset.y + offset.z * offset.z;

            // assume all fish types share same view radius and avoid raduis for temporary use
            if (sqrDst < viewRadius * viewRadius) {
                if (fishDatBuffer[id.x].type == 0) // prey
                {
                    if (neighbor_type == 0) // prey neighbor
                    {
                        fishDatBuffer[id.x].numFlockmates += 1;
                        fishDatBuffer[id.x].flockHeading += neighbor.direction;
                        fishDatBuffer[id.x].flockCentre += neighbor.position;

                        if (sqrDst < avoidRadius * avoidRadius) {
                            fishDatBuffer[id.x].separationHeading -= offset / sqrDst;
                        }
                    }
                    else if (neighbor_type == 1) // predator neighbor
                    {
                        // accumulate fear
                        fishDatBuffer[id.x].totFear += neighbor.threat * D0 / sqrt(sqrDst);
                        tmpMaxThreat = max(tmpMaxThreat, neighbor.threat * D0 / sqrt(sqrDst));

                        // get nearestPredatorPos
                        if(sqrDst < tempNearestDistSqr){
                            tempNearestDistSqr = sqrDst;
                            fishDatBuffer[id.x].nearestPredatorPos = fishDatBuffer[idxNeighbor].position;
                        }
                        // TODO: update focusser info
                        // TODO: after loop neighbors, if tempNearestDistSqr is really small, self is eaten
                    }

                    // no interest on pacifist neighbor
                }
                else if (fishDatBuffer[id.x].type == 1) // predator
                {
                    // only have interest on prey neighbor
                    if (neighbor_type == 0)
                    {
                        // TODO: if very very close, eatenPreyNumber++
                    }
                }
                else // pacifist
                {
                    // only have interest on pacifist neighbor
                    if (neighbor_type == 2)
                    {
                        // TODO: update focusser info
                    }
                }
            }
        }
    }
    fishDatBuffer[id.x].maxFear = tmpMaxThreat;
}